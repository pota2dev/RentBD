import { Review } from "@prisma/client";
import { prisma } from "@/lib/prisma";
import { clerkClient } from "@clerk/nextjs/server";

/**
 * Get reviews for a specific property
 */
export async function getPropertyReviews(propertyId: string) {
  try {
    const reviews = await prisma.review.findMany({
      where: {
        propertyId: propertyId,
      },
      include: {
        Tenant: true,
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    if (reviews.length === 0) return [];

    const userIds = [...new Set(reviews.map(r => r.tenantId))];
    const client = await clerkClient();
    const users = await client.users.getUserList({ userId: userIds, limit: 100 });
    
    const userMap = new Map(users.data.map(u => [u.id, u]));

    const reviewsWithUser = reviews.map(review => {
        const user = userMap.get(review.tenantId);
        return {
            ...review,
            Tenant: {
                ...review.Tenant,
                User: {
                    firstName: user?.firstName || null,
                    lastName: user?.lastName || null,
                    profilePicture: user?.imageUrl || null,
                }
            }
        };
    });

    return reviewsWithUser;
  } catch (error) {
    console.error("Error fetching reviews:", error);
    return [];
  }
}

/**
 * Check if a user can review a property.
 * Rules:
 * 1. Must have a confirmed/completed booking for this property.
 * 2. Must not have already reviewed this booking.
 */
export async function checkReviewEligibility(userId: string, propertyId: string) {
    try {
        // Find a completed booking for this property by this user that doesn't have a review
        const booking = await prisma.booking.findFirst({
            where: {
                propertyId: propertyId,
                tenantId: userId,
                status: "COMPLETED", // Assuming 'COMPLETED' is the status for a past valid booking
                Review: {
                    is: null // Ensure no review exists for this booking
                }
            }
        });

        if (booking) {
            return { eligible: true, bookingId: booking.id };
        } else {
             // Check if they have reviewed all their completed bookings
             const completedBookings = await prisma.booking.count({
                where: {
                    propertyId: propertyId,
                    tenantId: userId,
                    status: "COMPLETED"
                }
             });
             
             if (completedBookings === 0) {
                 return { eligible: false, message: "No completed bookings found for this property." };
             }
             
             return { eligible: false, message: "You have already reviewed your stay(s)." };
        }

    } catch (error) {
        console.error("Error checking review eligibility:", error);
        return { eligible: false, message: "Server error checking eligibility." };
    }
}

/**
 * Create a new review
 */
export async function createReview(data: {
    propertyId: string;
    userId: string;
    rating: number;
    reviewText?: string;
    bookingId: string;
}) {
    try {
        // Ensure Tenant record exists
        await prisma.tenant.upsert({
            where: { id: data.userId },
            create: { id: data.userId },
            update: {}
        });

        const review = await prisma.review.create({
            data: {
                // reviewId is autogenerated
                propertyId: data.propertyId,
                tenantId: data.userId,
                bookingId: data.bookingId,
                rating: data.rating,
                reviewText: data.reviewText,
            }
        });
        
        // Update property average rating (optional but good for performance)
        // We can do this async or here. For simplicity, let's recalculate.
        await updatePropertyRating(data.propertyId);

        return review;
    } catch (error) {
        console.error("Error creating review:", error);
        throw error;
    }
}

async function updatePropertyRating(propertyId: string) {
    const aggregations = await prisma.review.aggregate({
        where: { propertyId: propertyId },
        _avg: { rating: true },
        _count: { rating: true },
    });
    
    const newAverage = aggregations._avg.rating || 0;
    const newCount = aggregations._count.rating || 0;

    await prisma.property.update({
        where: { id: propertyId },
        data: {
            averageRating: newAverage,
            totalReviews: newCount,
        }
    });
}

/**
 * Update an existing review
 */
export async function updateReview(data: {
    reviewId: string;
    userId: string;
    rating: number;
    reviewText?: string;
}) {
    try {
        // Verify ownership
        const existingReview = await prisma.review.findUnique({
            where: { id: data.reviewId },
        });

        if (!existingReview || existingReview.tenantId !== data.userId) {
            throw new Error("Unauthorized or Review not found");
        }

        const updatedReview = await prisma.review.update({
            where: { id: data.reviewId },
            data: {
                rating: data.rating,
                reviewText: data.reviewText,
            }
        });

        // Recalculate average
        await updatePropertyRating(existingReview.propertyId);

        return updatedReview;
    } catch (error) {
        console.error("Error updating review:", error);
        throw error;
    }
}

/**
 * Delete a review
 */
export async function deleteReview(reviewId: string, userId: string) {
    try {
        // Verify ownership
        const existingReview = await prisma.review.findUnique({
            where: { id: reviewId },
        });

        if (!existingReview || existingReview.tenantId !== userId) {
            throw new Error("Unauthorized or Review not found");
        }

        await prisma.review.delete({
            where: { id: reviewId },
        });

        // Recalculate average
        await updatePropertyRating(existingReview.propertyId);

        return { success: true };
    } catch (error) {
        console.error("Error deleting review:", error);
        throw error;
    }
}
